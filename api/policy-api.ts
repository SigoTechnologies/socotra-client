/* tslint:disable */
/* eslint-disable */
/**
 * Socotra API Reference
 * Socotra REST API Description
 *
 * The version of the OpenAPI document: 1.3.191
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AutomatedUnderwritingResultResponse } from '../model';
// @ts-ignore
import { CancellationValueResponse } from '../model';
// @ts-ignore
import { CheckInvoicesResponse } from '../model';
// @ts-ignore
import { Claim3Response } from '../model';
// @ts-ignore
import { GetPolicyPriceResponse } from '../model';
// @ts-ignore
import { GraceLapseReinstatementResponse } from '../model';
// @ts-ignore
import { GracePeriodResponse } from '../model';
// @ts-ignore
import { LapseReinstatementResponse } from '../model';
// @ts-ignore
import { Policy2Response } from '../model';
// @ts-ignore
import { Policy2UpdateRequest } from '../model';
// @ts-ignore
import { PolicyCreateRequest4 } from '../model';
// @ts-ignore
import { PolicyDocumentRemoveRequest } from '../model';
// @ts-ignore
import { PolicyEndorsementIssueRequest } from '../model';
// @ts-ignore
import { PolicyPriceChangeResponse } from '../model';
// @ts-ignore
import { PolicyPriceResponse } from '../model';
// @ts-ignore
import { RenewalIssueRequest } from '../model';
/**
 * PolicyApi - axios parameter creator
 * @export
 */
export const PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addDocumentUsingPOST
         * @param {string} displayName 
         * @param {string} documentType 
         * @param {string} policyLocator 
         * @param {any} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentUsingPOST: async (displayName: string, documentType: string, policyLocator: string, document: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayName' is not null or undefined
            assertParamExists('addDocumentUsingPOST', 'displayName', displayName)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('addDocumentUsingPOST', 'documentType', documentType)
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('addDocumentUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('addDocumentUsingPOST', 'document', document)
            const localVarPath = `/policy/{policyLocator}/addDocument`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (displayName !== undefined) {
                localVarQueryParameter['displayName'] = displayName;
            }

            if (documentType !== undefined) {
                localVarQueryParameter['documentType'] = documentType;
            }


            if (document !== undefined) { 
                localVarFormParams.append('document', document as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary checkInvoicesUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInvoicesUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('checkInvoicesUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/checkInvoices`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createPolicyUsingPOST
         * @param {PolicyCreateRequest4} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyUsingPOST: async (createRequest: PolicyCreateRequest4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('createPolicyUsingPOST', 'createRequest', createRequest)
            const localVarPath = `/policy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createReinstatementUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReinstatementUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('createReinstatementUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/createReinstatement`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary discardPolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discardPolicyUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('discardPolicyUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/discard`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary finalizePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizePolicyUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('finalizePolicyUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/finalize`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAutomatedUnderwritingResultUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomatedUnderwritingResultUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getAutomatedUnderwritingResultUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/automatedUnderwritingResult`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getCancellationValueUsingGET
         * @param {number} coverageEndTimestamp 
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCancellationValueUsingGET: async (coverageEndTimestamp: number, policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coverageEndTimestamp' is not null or undefined
            assertParamExists('getCancellationValueUsingGET', 'coverageEndTimestamp', coverageEndTimestamp)
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getCancellationValueUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/cancellationValue`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (coverageEndTimestamp !== undefined) {
                localVarQueryParameter['coverageEndTimestamp'] = coverageEndTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getClaimsByPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimsByPolicyUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getClaimsByPolicyUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/claims`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGraceLapseReinstatementsUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraceLapseReinstatementsUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getGraceLapseReinstatementsUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/graceLapseReinstatements`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getGracePeriodsByPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGracePeriodsByPolicyUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getGracePeriodsByPolicyUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/gracePeriods`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getNonSettledGraceUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSettledGraceUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getNonSettledGraceUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/true/grace`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPolicyLocatorUsingGET
         * @param {string} displayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyLocatorUsingGET: async (displayId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayId' is not null or undefined
            assertParamExists('getPolicyLocatorUsingGET', 'displayId', displayId)
            const localVarPath = `/policy/locator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (displayId !== undefined) {
                localVarQueryParameter['displayId'] = displayId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPolicyPriceUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyPriceUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getPolicyPriceUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/price`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getPolicyUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getReinstatementsUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReinstatementsUsingGET: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('getReinstatementsUsingGET', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/reinstatements`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueCancellationUsingPOST
         * @param {string} policyLocator 
         * @param {object} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCancellationUsingPOST: async (policyLocator: string, request: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('issueCancellationUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueCancellationUsingPOST', 'request', request)
            const localVarPath = `/policy/{policyLocator}/cancel`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueEndorsementUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyEndorsementIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEndorsementUsingPOST: async (policyLocator: string, request: PolicyEndorsementIssueRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('issueEndorsementUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueEndorsementUsingPOST', 'request', request)
            const localVarPath = `/policy/{policyLocator}/endorse`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueNextInvoiceUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNextInvoiceUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('issueNextInvoiceUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/issueNextInvoice`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issuePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePolicyUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('issuePolicyUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/issue`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueRenewalUsingPOST
         * @param {string} policyLocator 
         * @param {RenewalIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRenewalUsingPOST: async (policyLocator: string, request: RenewalIssueRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('issueRenewalUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('issueRenewalUsingPOST', 'request', request)
            const localVarPath = `/policy/{policyLocator}/issueRenewal`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary issueWithdrawalUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueWithdrawalUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('issueWithdrawalUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/withdraw`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary previewEndorsementPriceUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyEndorsementIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewEndorsementPriceUsingPOST: async (policyLocator: string, request: PolicyEndorsementIssueRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('previewEndorsementPriceUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('previewEndorsementPriceUsingPOST', 'request', request)
            const localVarPath = `/policy/{policyLocator}/previewEndorsementPrice`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary previewRenewalPriceUsingPOST
         * @param {string} policyLocator 
         * @param {RenewalIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewRenewalPriceUsingPOST: async (policyLocator: string, request: RenewalIssueRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('previewRenewalPriceUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('previewRenewalPriceUsingPOST', 'request', request)
            const localVarPath = `/policy/{policyLocator}/previewRenewalPrice`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary pricePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePolicyUsingPOST: async (policyLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('pricePolicyUsingPOST', 'policyLocator', policyLocator)
            const localVarPath = `/policy/{policyLocator}/price`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary removeDocumentUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyDocumentRemoveRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDocumentUsingPOST: async (policyLocator: string, request: PolicyDocumentRemoveRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('removeDocumentUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('removeDocumentUsingPOST', 'request', request)
            const localVarPath = `/policy/{policyLocator}/removeDocument`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {Policy2UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyUsingPOST: async (policyLocator: string, updateRequest: Policy2UpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyLocator' is not null or undefined
            assertParamExists('updatePolicyUsingPOST', 'policyLocator', policyLocator)
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updatePolicyUsingPOST', 'updateRequest', updateRequest)
            const localVarPath = `/policy/{policyLocator}/update`
                .replace(`{${"policyLocator"}}`, encodeURIComponent(String(policyLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PolicyApi - functional programming interface
 * @export
 */
export const PolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addDocumentUsingPOST
         * @param {string} displayName 
         * @param {string} documentType 
         * @param {string} policyLocator 
         * @param {any} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDocumentUsingPOST(displayName: string, documentType: string, policyLocator: string, document: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDocumentUsingPOST(displayName, documentType, policyLocator, document, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary checkInvoicesUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkInvoicesUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckInvoicesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkInvoicesUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createPolicyUsingPOST
         * @param {PolicyCreateRequest4} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyUsingPOST(createRequest: PolicyCreateRequest4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyUsingPOST(createRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createReinstatementUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReinstatementUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LapseReinstatementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReinstatementUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary discardPolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discardPolicyUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discardPolicyUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary finalizePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async finalizePolicyUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.finalizePolicyUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAutomatedUnderwritingResultUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutomatedUnderwritingResultUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomatedUnderwritingResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutomatedUnderwritingResultUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getCancellationValueUsingGET
         * @param {number} coverageEndTimestamp 
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCancellationValueUsingGET(coverageEndTimestamp: number, policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancellationValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCancellationValueUsingGET(coverageEndTimestamp, policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getClaimsByPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimsByPolicyUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Claim3Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimsByPolicyUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGraceLapseReinstatementsUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraceLapseReinstatementsUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GraceLapseReinstatementResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraceLapseReinstatementsUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getGracePeriodsByPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGracePeriodsByPolicyUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GracePeriodResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGracePeriodsByPolicyUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getNonSettledGraceUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNonSettledGraceUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GracePeriodResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonSettledGraceUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPolicyLocatorUsingGET
         * @param {string} displayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyLocatorUsingGET(displayId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyLocatorUsingGET(displayId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPolicyPriceUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyPriceUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPolicyPriceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyPriceUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getReinstatementsUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReinstatementsUsingGET(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LapseReinstatementResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReinstatementsUsingGET(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueCancellationUsingPOST
         * @param {string} policyLocator 
         * @param {object} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCancellationUsingPOST(policyLocator: string, request: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCancellationUsingPOST(policyLocator, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueEndorsementUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyEndorsementIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEndorsementUsingPOST(policyLocator: string, request: PolicyEndorsementIssueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEndorsementUsingPOST(policyLocator, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueNextInvoiceUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueNextInvoiceUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueNextInvoiceUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issuePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePolicyUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePolicyUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueRenewalUsingPOST
         * @param {string} policyLocator 
         * @param {RenewalIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRenewalUsingPOST(policyLocator: string, request: RenewalIssueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRenewalUsingPOST(policyLocator, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary issueWithdrawalUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueWithdrawalUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueWithdrawalUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary previewEndorsementPriceUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyEndorsementIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewEndorsementPriceUsingPOST(policyLocator: string, request: PolicyEndorsementIssueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyPriceChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewEndorsementPriceUsingPOST(policyLocator, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary previewRenewalPriceUsingPOST
         * @param {string} policyLocator 
         * @param {RenewalIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewRenewalPriceUsingPOST(policyLocator: string, request: RenewalIssueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyPriceChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewRenewalPriceUsingPOST(policyLocator, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary pricePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricePolicyUsingPOST(policyLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyPriceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricePolicyUsingPOST(policyLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary removeDocumentUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyDocumentRemoveRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDocumentUsingPOST(policyLocator: string, request: PolicyDocumentRemoveRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDocumentUsingPOST(policyLocator, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {Policy2UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyUsingPOST(policyLocator: string, updateRequest: Policy2UpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy2Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyUsingPOST(policyLocator, updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PolicyApi - factory interface
 * @export
 */
export const PolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PolicyApiFp(configuration)
    return {
        /**
         * 
         * @summary addDocumentUsingPOST
         * @param {string} displayName 
         * @param {string} documentType 
         * @param {string} policyLocator 
         * @param {any} document 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentUsingPOST(displayName: string, documentType: string, policyLocator: string, document: any, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.addDocumentUsingPOST(displayName, documentType, policyLocator, document, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary checkInvoicesUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkInvoicesUsingGET(policyLocator: string, options?: any): AxiosPromise<CheckInvoicesResponse> {
            return localVarFp.checkInvoicesUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createPolicyUsingPOST
         * @param {PolicyCreateRequest4} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyUsingPOST(createRequest: PolicyCreateRequest4, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.createPolicyUsingPOST(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createReinstatementUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReinstatementUsingPOST(policyLocator: string, options?: any): AxiosPromise<LapseReinstatementResponse> {
            return localVarFp.createReinstatementUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary discardPolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discardPolicyUsingPOST(policyLocator: string, options?: any): AxiosPromise<void> {
            return localVarFp.discardPolicyUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary finalizePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizePolicyUsingPOST(policyLocator: string, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.finalizePolicyUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAutomatedUnderwritingResultUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutomatedUnderwritingResultUsingGET(policyLocator: string, options?: any): AxiosPromise<AutomatedUnderwritingResultResponse> {
            return localVarFp.getAutomatedUnderwritingResultUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getCancellationValueUsingGET
         * @param {number} coverageEndTimestamp 
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCancellationValueUsingGET(coverageEndTimestamp: number, policyLocator: string, options?: any): AxiosPromise<CancellationValueResponse> {
            return localVarFp.getCancellationValueUsingGET(coverageEndTimestamp, policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getClaimsByPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimsByPolicyUsingGET(policyLocator: string, options?: any): AxiosPromise<Array<Claim3Response>> {
            return localVarFp.getClaimsByPolicyUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGraceLapseReinstatementsUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraceLapseReinstatementsUsingGET(policyLocator: string, options?: any): AxiosPromise<Array<GraceLapseReinstatementResponse>> {
            return localVarFp.getGraceLapseReinstatementsUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getGracePeriodsByPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGracePeriodsByPolicyUsingGET(policyLocator: string, options?: any): AxiosPromise<Array<GracePeriodResponse>> {
            return localVarFp.getGracePeriodsByPolicyUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getNonSettledGraceUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonSettledGraceUsingGET(policyLocator: string, options?: any): AxiosPromise<Array<GracePeriodResponse>> {
            return localVarFp.getNonSettledGraceUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPolicyLocatorUsingGET
         * @param {string} displayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyLocatorUsingGET(displayId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPolicyLocatorUsingGET(displayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPolicyPriceUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyPriceUsingGET(policyLocator: string, options?: any): AxiosPromise<GetPolicyPriceResponse> {
            return localVarFp.getPolicyPriceUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPolicyUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyUsingGET(policyLocator: string, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.getPolicyUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getReinstatementsUsingGET
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReinstatementsUsingGET(policyLocator: string, options?: any): AxiosPromise<Array<LapseReinstatementResponse>> {
            return localVarFp.getReinstatementsUsingGET(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueCancellationUsingPOST
         * @param {string} policyLocator 
         * @param {object} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCancellationUsingPOST(policyLocator: string, request: object, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.issueCancellationUsingPOST(policyLocator, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueEndorsementUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyEndorsementIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEndorsementUsingPOST(policyLocator: string, request: PolicyEndorsementIssueRequest, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.issueEndorsementUsingPOST(policyLocator, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueNextInvoiceUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNextInvoiceUsingPOST(policyLocator: string, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.issueNextInvoiceUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issuePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePolicyUsingPOST(policyLocator: string, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.issuePolicyUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueRenewalUsingPOST
         * @param {string} policyLocator 
         * @param {RenewalIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRenewalUsingPOST(policyLocator: string, request: RenewalIssueRequest, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.issueRenewalUsingPOST(policyLocator, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary issueWithdrawalUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueWithdrawalUsingPOST(policyLocator: string, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.issueWithdrawalUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary previewEndorsementPriceUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyEndorsementIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewEndorsementPriceUsingPOST(policyLocator: string, request: PolicyEndorsementIssueRequest, options?: any): AxiosPromise<PolicyPriceChangeResponse> {
            return localVarFp.previewEndorsementPriceUsingPOST(policyLocator, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary previewRenewalPriceUsingPOST
         * @param {string} policyLocator 
         * @param {RenewalIssueRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewRenewalPriceUsingPOST(policyLocator: string, request: RenewalIssueRequest, options?: any): AxiosPromise<PolicyPriceChangeResponse> {
            return localVarFp.previewRenewalPriceUsingPOST(policyLocator, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary pricePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricePolicyUsingPOST(policyLocator: string, options?: any): AxiosPromise<PolicyPriceResponse> {
            return localVarFp.pricePolicyUsingPOST(policyLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary removeDocumentUsingPOST
         * @param {string} policyLocator 
         * @param {PolicyDocumentRemoveRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDocumentUsingPOST(policyLocator: string, request: PolicyDocumentRemoveRequest, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.removeDocumentUsingPOST(policyLocator, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePolicyUsingPOST
         * @param {string} policyLocator 
         * @param {Policy2UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyUsingPOST(policyLocator: string, updateRequest: Policy2UpdateRequest, options?: any): AxiosPromise<Policy2Response> {
            return localVarFp.updatePolicyUsingPOST(policyLocator, updateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PolicyApi - object-oriented interface
 * @export
 * @class PolicyApi
 * @extends {BaseAPI}
 */
export class PolicyApi extends BaseAPI {
    /**
     * 
     * @summary addDocumentUsingPOST
     * @param {string} displayName 
     * @param {string} documentType 
     * @param {string} policyLocator 
     * @param {any} document 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public addDocumentUsingPOST(displayName: string, documentType: string, policyLocator: string, document: any, options?: any) {
        return PolicyApiFp(this.configuration).addDocumentUsingPOST(displayName, documentType, policyLocator, document, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary checkInvoicesUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public checkInvoicesUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).checkInvoicesUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createPolicyUsingPOST
     * @param {PolicyCreateRequest4} createRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public createPolicyUsingPOST(createRequest: PolicyCreateRequest4, options?: any) {
        return PolicyApiFp(this.configuration).createPolicyUsingPOST(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createReinstatementUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public createReinstatementUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).createReinstatementUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary discardPolicyUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public discardPolicyUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).discardPolicyUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary finalizePolicyUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public finalizePolicyUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).finalizePolicyUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAutomatedUnderwritingResultUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getAutomatedUnderwritingResultUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getAutomatedUnderwritingResultUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getCancellationValueUsingGET
     * @param {number} coverageEndTimestamp 
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getCancellationValueUsingGET(coverageEndTimestamp: number, policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getCancellationValueUsingGET(coverageEndTimestamp, policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getClaimsByPolicyUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getClaimsByPolicyUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getClaimsByPolicyUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGraceLapseReinstatementsUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getGraceLapseReinstatementsUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getGraceLapseReinstatementsUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getGracePeriodsByPolicyUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getGracePeriodsByPolicyUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getGracePeriodsByPolicyUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getNonSettledGraceUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getNonSettledGraceUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getNonSettledGraceUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPolicyLocatorUsingGET
     * @param {string} displayId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicyLocatorUsingGET(displayId: string, options?: any) {
        return PolicyApiFp(this.configuration).getPolicyLocatorUsingGET(displayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPolicyPriceUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicyPriceUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getPolicyPriceUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPolicyUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getPolicyUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getPolicyUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getReinstatementsUsingGET
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public getReinstatementsUsingGET(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).getReinstatementsUsingGET(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueCancellationUsingPOST
     * @param {string} policyLocator 
     * @param {object} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public issueCancellationUsingPOST(policyLocator: string, request: object, options?: any) {
        return PolicyApiFp(this.configuration).issueCancellationUsingPOST(policyLocator, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueEndorsementUsingPOST
     * @param {string} policyLocator 
     * @param {PolicyEndorsementIssueRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public issueEndorsementUsingPOST(policyLocator: string, request: PolicyEndorsementIssueRequest, options?: any) {
        return PolicyApiFp(this.configuration).issueEndorsementUsingPOST(policyLocator, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueNextInvoiceUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public issueNextInvoiceUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).issueNextInvoiceUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issuePolicyUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public issuePolicyUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).issuePolicyUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueRenewalUsingPOST
     * @param {string} policyLocator 
     * @param {RenewalIssueRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public issueRenewalUsingPOST(policyLocator: string, request: RenewalIssueRequest, options?: any) {
        return PolicyApiFp(this.configuration).issueRenewalUsingPOST(policyLocator, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary issueWithdrawalUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public issueWithdrawalUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).issueWithdrawalUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary previewEndorsementPriceUsingPOST
     * @param {string} policyLocator 
     * @param {PolicyEndorsementIssueRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public previewEndorsementPriceUsingPOST(policyLocator: string, request: PolicyEndorsementIssueRequest, options?: any) {
        return PolicyApiFp(this.configuration).previewEndorsementPriceUsingPOST(policyLocator, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary previewRenewalPriceUsingPOST
     * @param {string} policyLocator 
     * @param {RenewalIssueRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public previewRenewalPriceUsingPOST(policyLocator: string, request: RenewalIssueRequest, options?: any) {
        return PolicyApiFp(this.configuration).previewRenewalPriceUsingPOST(policyLocator, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary pricePolicyUsingPOST
     * @param {string} policyLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public pricePolicyUsingPOST(policyLocator: string, options?: any) {
        return PolicyApiFp(this.configuration).pricePolicyUsingPOST(policyLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary removeDocumentUsingPOST
     * @param {string} policyLocator 
     * @param {PolicyDocumentRemoveRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public removeDocumentUsingPOST(policyLocator: string, request: PolicyDocumentRemoveRequest, options?: any) {
        return PolicyApiFp(this.configuration).removeDocumentUsingPOST(policyLocator, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePolicyUsingPOST
     * @param {string} policyLocator 
     * @param {Policy2UpdateRequest} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PolicyApi
     */
    public updatePolicyUsingPOST(policyLocator: string, updateRequest: Policy2UpdateRequest, options?: any) {
        return PolicyApiFp(this.configuration).updatePolicyUsingPOST(policyLocator, updateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
