/* tslint:disable */
/* eslint-disable */
/**
 * Socotra API Reference
 * Socotra REST API Description
 *
 * The version of the OpenAPI document: 1.3.191
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountAddRequest } from '../model';
// @ts-ignore
import { AccountPagedResultResponse } from '../model';
// @ts-ignore
import { AccountPasswordRequest } from '../model';
// @ts-ignore
import { AccountResponse } from '../model';
// @ts-ignore
import { AccountStatusRequest } from '../model';
// @ts-ignore
import { AccountUnlockRequest } from '../model';
// @ts-ignore
import { AccountUpdateRequest } from '../model';
// @ts-ignore
import { AuthenticateRequest3 } from '../model';
// @ts-ignore
import { AuthenticateResponse3 } from '../model';
// @ts-ignore
import { Claim3CreateRequest } from '../model';
// @ts-ignore
import { Claim3Response } from '../model';
// @ts-ignore
import { Claim3UpdateRequest } from '../model';
// @ts-ignore
import { DeployTestConfigurationResponse } from '../model';
// @ts-ignore
import { EventPageResponse } from '../model';
// @ts-ignore
import { ExternalServiceIntegrationAddRequest } from '../model';
// @ts-ignore
import { ExternalServiceIntegrationBatchUpdateRequest } from '../model';
// @ts-ignore
import { ExternalServiceIntegrationUpdateRequest } from '../model';
// @ts-ignore
import { ExternalServiceIntegrationsResponse } from '../model';
// @ts-ignore
import { HealthResponse } from '../model';
// @ts-ignore
import { PasswordChangeRequest } from '../model';
// @ts-ignore
import { PolicyholderCreateRequest2 } from '../model';
// @ts-ignore
import { PolicyholderResponse3 } from '../model';
// @ts-ignore
import { PolicyholderUpdateRequest2 } from '../model';
// @ts-ignore
import { QueryRequest } from '../model';
// @ts-ignore
import { QueryResponse } from '../model';
// @ts-ignore
import { ReserveHistoryResponse } from '../model';
// @ts-ignore
import { SsoAccountResponse } from '../model';
// @ts-ignore
import { SsoAddInternalAccountRequest } from '../model';
// @ts-ignore
import { SsoFindByHostnameRequest } from '../model';
// @ts-ignore
import { SsoFindByTenantRequest } from '../model';
// @ts-ignore
import { SsoFindTenantsForAdminResponse } from '../model';
// @ts-ignore
import { SsoQueryLogRequest } from '../model';
// @ts-ignore
import { SubClaimPayableListsResponse } from '../model';
// @ts-ignore
import { SubClaimSummary } from '../model';
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addAccountUsingPOST
         * @param {AccountAddRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountUsingPOST: async (accountRequest: AccountAddRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountRequest' is not null or undefined
            assertParamExists('addAccountUsingPOST', 'accountRequest', accountRequest)
            const localVarPath = `/account/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary addExternalServiceIntegrationUsingPOST
         * @param {ExternalServiceIntegrationAddRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExternalServiceIntegrationUsingPOST: async (request: ExternalServiceIntegrationAddRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('addExternalServiceIntegrationUsingPOST', 'request', request)
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary authenticate3UsingPOST
         * @param {string} [hostName] 
         * @param {string} [tenantName] 
         * @param {AuthenticateRequest3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate3UsingPOST: async (hostName?: string, tenantName?: string, body?: AuthenticateRequest3, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hostName !== undefined) {
                localVarQueryParameter['hostName'] = hostName;
            }

            if (tenantName !== undefined) {
                localVarQueryParameter['tenantName'] = tenantName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary authenticateAdminUsingPOST
         * @param {string} [hostName] 
         * @param {string} [tenantLocator] 
         * @param {string} [tenantName] 
         * @param {AuthenticateRequest3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAdminUsingPOST: async (hostName?: string, tenantLocator?: string, tenantName?: string, body?: AuthenticateRequest3, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/authenticateAdmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hostName !== undefined) {
                localVarQueryParameter['hostName'] = hostName;
            }

            if (tenantLocator !== undefined) {
                localVarQueryParameter['tenantLocator'] = tenantLocator;
            }

            if (tenantName !== undefined) {
                localVarQueryParameter['tenantName'] = tenantName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary batchUpdateExternalServiceIntegrationsUsingPUT
         * @param {ExternalServiceIntegrationBatchUpdateRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateExternalServiceIntegrationsUsingPUT: async (request: ExternalServiceIntegrationBatchUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('batchUpdateExternalServiceIntegrationsUsingPUT', 'request', request)
            const localVarPath = `/integrations/batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createClaim3UsingPOST
         * @param {Claim3CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClaim3UsingPOST: async (createRequest: Claim3CreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRequest' is not null or undefined
            assertParamExists('createClaim3UsingPOST', 'createRequest', createRequest)
            const localVarPath = `/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createPolicyholder3UsingPOST
         * @param {PolicyholderCreateRequest2} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyholder3UsingPOST: async (request: PolicyholderCreateRequest2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('createPolicyholder3UsingPOST', 'request', request)
            const localVarPath = `/policyholder/v2/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary createSsoInternalAccountUsingPOST
         * @param {SsoAddInternalAccountRequest} internalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSsoInternalAccountUsingPOST: async (internalAccountRequest: SsoAddInternalAccountRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'internalAccountRequest' is not null or undefined
            assertParamExists('createSsoInternalAccountUsingPOST', 'internalAccountRequest', internalAccountRequest)
            const localVarPath = `/account/sso/accountInternal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(internalAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteAccountUsingDELETE
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountUsingDELETE: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccountUsingDELETE', 'accountId', accountId)
            const localVarPath = `/account/v1/account/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteExternalServiceIntegrationUsingDELETE
         * @param {string} integrationName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExternalServiceIntegrationUsingDELETE: async (integrationName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationName' is not null or undefined
            assertParamExists('deleteExternalServiceIntegrationUsingDELETE', 'integrationName', integrationName)
            const localVarPath = `/integrations/{integrationName}`
                .replace(`{${"integrationName"}}`, encodeURIComponent(String(integrationName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The operation accepts zip archive, which contains Java Script files. Multipart form with file parameter is expected.
         * @summary deployScriptsUsingPOST
         * @param {any} file 
         * @param {string} [tenantLocator] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployScriptsUsingPOST: async (file: any, tenantLocator?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('deployScriptsUsingPOST', 'file', file)
            const localVarPath = `/scripts/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (tenantLocator !== undefined) {
                localVarQueryParameter['tenantLocator'] = tenantLocator;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a test configuration
         * @summary DeployTestConfigurationUsingPOST
         * @param {any} zipFile 
         * @param {string} [tenantNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTestConfigurationUsingPOST: async (zipFile: any, tenantNameSuffix?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'zipFile' is not null or undefined
            assertParamExists('deployTestConfigurationUsingPOST', 'zipFile', zipFile)
            const localVarPath = `/configuration/deployTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (tenantNameSuffix !== undefined) { 
                localVarFormParams.append('tenantNameSuffix', tenantNameSuffix as any);
            }
    
            if (zipFile !== undefined) { 
                localVarFormParams.append('zipFile', zipFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary discardClaimUsingPOST
         * @param {string} claimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discardClaimUsingPOST: async (claimLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimLocator' is not null or undefined
            assertParamExists('discardClaimUsingPOST', 'claimLocator', claimLocator)
            const localVarPath = `/claim/{claimLocator}/discard`
                .replace(`{${"claimLocator"}}`, encodeURIComponent(String(claimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findAccountsByHostnameUsingPOST
         * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByHostnameUsingPOST: async (ssoFindByHostnameRequest: SsoFindByHostnameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ssoFindByHostnameRequest' is not null or undefined
            assertParamExists('findAccountsByHostnameUsingPOST', 'ssoFindByHostnameRequest', ssoFindByHostnameRequest)
            const localVarPath = `/account/sso/findByHostname`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ssoFindByHostnameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findAccountsByTenantUsingPOST
         * @param {SsoFindByTenantRequest} ssoFindByTenantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByTenantUsingPOST: async (ssoFindByTenantRequest: SsoFindByTenantRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ssoFindByTenantRequest' is not null or undefined
            assertParamExists('findAccountsByTenantUsingPOST', 'ssoFindByTenantRequest', ssoFindByTenantRequest)
            const localVarPath = `/account/sso/findByTenant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ssoFindByTenantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAccountUsingGET
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountUsingGET: async (accountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountUsingGET', 'accountId', accountId)
            const localVarPath = `/account/v1/account/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAccountsByTenantUsingGET
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsByTenantUsingGET: async (cursor?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/v1/findByTenant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deliver events with user attribution
         * @summary getAttributedEventsUsingGET
         * @param {number} [endTimestamp] 
         * @param {string} [eventType] 
         * @param {number} [pageSize] 
         * @param {string} [pagingToken] 
         * @param {number} [startTimestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributedEventsUsingGET: async (endTimestamp?: number, eventType?: string, pageSize?: number, pagingToken?: string, startTimestamp?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/eventstream/attributedEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endTimestamp !== undefined) {
                localVarQueryParameter['endTimestamp'] = endTimestamp;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pagingToken !== undefined) {
                localVarQueryParameter['pagingToken'] = pagingToken;
            }

            if (startTimestamp !== undefined) {
                localVarQueryParameter['startTimestamp'] = startTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getClaim3UsingGET
         * @param {string} claimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaim3UsingGET: async (claimLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimLocator' is not null or undefined
            assertParamExists('getClaim3UsingGET', 'claimLocator', claimLocator)
            const localVarPath = `/claim/{claimLocator}`
                .replace(`{${"claimLocator"}}`, encodeURIComponent(String(claimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getExternalServiceIntegrationsUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalServiceIntegrationsUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getExternalServiceIntegrationsUsingPOST
         * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalServiceIntegrationsUsingPOST: async (ssoFindByHostnameRequest: SsoFindByHostnameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ssoFindByHostnameRequest' is not null or undefined
            assertParamExists('getExternalServiceIntegrationsUsingPOST', 'ssoFindByHostnameRequest', ssoFindByHostnameRequest)
            const localVarPath = `/account/sso/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ssoFindByHostnameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getFeaturesSummaryUsingGET
         * @param {string} [locators] 
         * @param {string} [memoNamespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesSummaryUsingGET: async (locators?: string, memoNamespace?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dailystats/features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (locators !== undefined) {
                localVarQueryParameter['locators'] = locators;
            }

            if (memoNamespace !== undefined) {
                localVarQueryParameter['memoNamespace'] = memoNamespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHealthUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPayablesOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayablesOfSubClaimUsingGET: async (subClaimLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subClaimLocator' is not null or undefined
            assertParamExists('getPayablesOfSubClaimUsingGET', 'subClaimLocator', subClaimLocator)
            const localVarPath = `/subClaim/{subClaimLocator}/payables`
                .replace(`{${"subClaimLocator"}}`, encodeURIComponent(String(subClaimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPolicyholder3UsingGET
         * @param {string} policyholderLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyholder3UsingGET: async (policyholderLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyholderLocator' is not null or undefined
            assertParamExists('getPolicyholder3UsingGET', 'policyholderLocator', policyholderLocator)
            const localVarPath = `/policyholder/v2/{policyholderLocator}`
                .replace(`{${"policyholderLocator"}}`, encodeURIComponent(String(policyholderLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getReserveHistoryUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReserveHistoryUsingGET: async (subClaimLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subClaimLocator' is not null or undefined
            assertParamExists('getReserveHistoryUsingGET', 'subClaimLocator', subClaimLocator)
            const localVarPath = `/subClaim/{subClaimLocator}/reserveHistory`
                .replace(`{${"subClaimLocator"}}`, encodeURIComponent(String(subClaimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getReservesOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservesOfSubClaimUsingGET: async (subClaimLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subClaimLocator' is not null or undefined
            assertParamExists('getReservesOfSubClaimUsingGET', 'subClaimLocator', subClaimLocator)
            const localVarPath = `/subClaim/{subClaimLocator}/reserves`
                .replace(`{${"subClaimLocator"}}`, encodeURIComponent(String(subClaimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSummaryOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryOfSubClaimUsingGET: async (subClaimLocator: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subClaimLocator' is not null or undefined
            assertParamExists('getSummaryOfSubClaimUsingGET', 'subClaimLocator', subClaimLocator)
            const localVarPath = `/subClaim/{subClaimLocator}/summary`
                .replace(`{${"subClaimLocator"}}`, encodeURIComponent(String(subClaimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary hostnameForAdminUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostnameForAdminUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/sso/findTenantsForAdmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary querySsoLogsUsingPOST
         * @param {SsoQueryLogRequest} queryLogs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySsoLogsUsingPOST: async (queryLogs: SsoQueryLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryLogs' is not null or undefined
            assertParamExists('querySsoLogsUsingPOST', 'queryLogs', queryLogs)
            const localVarPath = `/account/sso/queryLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryLogs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The POST body contains JSON with parameters for retrieving scripting logs.
         * @summary queryUsingPOST
         * @param {QueryRequest} query 
         * @param {string} [tenantLocator] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUsingPOST: async (query: QueryRequest, tenantLocator?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('queryUsingPOST', 'query', query)
            const localVarPath = `/scripts/queryLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenantLocator !== undefined) {
                localVarQueryParameter['tenantLocator'] = tenantLocator;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(query, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary renewAuthentication3UsingPOST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewAuthentication3UsingPOST: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/renewAuthentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setPasswordUsingPATCH
         * @param {PasswordChangeRequest} passwordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordUsingPATCH: async (passwordRequest: PasswordChangeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordRequest' is not null or undefined
            assertParamExists('setPasswordUsingPATCH', 'passwordRequest', passwordRequest)
            const localVarPath = `/account/v1/accounts/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setPasswordUsingPUT
         * @param {string} accountId 
         * @param {AccountPasswordRequest} passwordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordUsingPUT: async (accountId: string, passwordRequest: AccountPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('setPasswordUsingPUT', 'accountId', accountId)
            // verify required parameter 'passwordRequest' is not null or undefined
            assertParamExists('setPasswordUsingPUT', 'passwordRequest', passwordRequest)
            const localVarPath = `/account/v1/account/{accountId}/password`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary setStatusUsingPUT
         * @param {string} accountId 
         * @param {AccountStatusRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatusUsingPUT: async (accountId: string, request: AccountStatusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('setStatusUsingPUT', 'accountId', accountId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('setStatusUsingPUT', 'request', request)
            const localVarPath = `/account/v1/account/{accountId}/status`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unlockAccountUsingPOST
         * @param {AccountUnlockRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccountUsingPOST: async (request: AccountUnlockRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('unlockAccountUsingPOST', 'request', request)
            const localVarPath = `/account/unlock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateAccountUsingPATCH
         * @param {string} accountId 
         * @param {AccountUpdateRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountUsingPATCH: async (accountId: string, accountRequest: AccountUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateAccountUsingPATCH', 'accountId', accountId)
            // verify required parameter 'accountRequest' is not null or undefined
            assertParamExists('updateAccountUsingPATCH', 'accountRequest', accountRequest)
            const localVarPath = `/account/v1/account/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateClaim3UsingPOST
         * @param {string} claimLocator 
         * @param {Claim3UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClaim3UsingPOST: async (claimLocator: string, updateRequest: Claim3UpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimLocator' is not null or undefined
            assertParamExists('updateClaim3UsingPOST', 'claimLocator', claimLocator)
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updateClaim3UsingPOST', 'updateRequest', updateRequest)
            const localVarPath = `/claim/{claimLocator}/update`
                .replace(`{${"claimLocator"}}`, encodeURIComponent(String(claimLocator)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateExternalServiceIntegrationUsingPUT
         * @param {string} integrationName 
         * @param {ExternalServiceIntegrationUpdateRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalServiceIntegrationUsingPUT: async (integrationName: string, request: ExternalServiceIntegrationUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationName' is not null or undefined
            assertParamExists('updateExternalServiceIntegrationUsingPUT', 'integrationName', integrationName)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateExternalServiceIntegrationUsingPUT', 'request', request)
            const localVarPath = `/integrations/{integrationName}`
                .replace(`{${"integrationName"}}`, encodeURIComponent(String(integrationName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updatePolicyholder3UsingPOST
         * @param {PolicyholderUpdateRequest2} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyholder3UsingPOST: async (updateRequest: PolicyholderUpdateRequest2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateRequest' is not null or undefined
            assertParamExists('updatePolicyholder3UsingPOST', 'updateRequest', updateRequest)
            const localVarPath = `/policyholder/v2/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary addAccountUsingPOST
         * @param {AccountAddRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAccountUsingPOST(accountRequest: AccountAddRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAccountUsingPOST(accountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary addExternalServiceIntegrationUsingPOST
         * @param {ExternalServiceIntegrationAddRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addExternalServiceIntegrationUsingPOST(request: ExternalServiceIntegrationAddRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalServiceIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addExternalServiceIntegrationUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary authenticate3UsingPOST
         * @param {string} [hostName] 
         * @param {string} [tenantName] 
         * @param {AuthenticateRequest3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate3UsingPOST(hostName?: string, tenantName?: string, body?: AuthenticateRequest3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateResponse3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate3UsingPOST(hostName, tenantName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary authenticateAdminUsingPOST
         * @param {string} [hostName] 
         * @param {string} [tenantLocator] 
         * @param {string} [tenantName] 
         * @param {AuthenticateRequest3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateAdminUsingPOST(hostName?: string, tenantLocator?: string, tenantName?: string, body?: AuthenticateRequest3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateResponse3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateAdminUsingPOST(hostName, tenantLocator, tenantName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary batchUpdateExternalServiceIntegrationsUsingPUT
         * @param {ExternalServiceIntegrationBatchUpdateRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchUpdateExternalServiceIntegrationsUsingPUT(request: ExternalServiceIntegrationBatchUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalServiceIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchUpdateExternalServiceIntegrationsUsingPUT(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createClaim3UsingPOST
         * @param {Claim3CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClaim3UsingPOST(createRequest: Claim3CreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClaim3UsingPOST(createRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createPolicyholder3UsingPOST
         * @param {PolicyholderCreateRequest2} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyholder3UsingPOST(request: PolicyholderCreateRequest2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyholderResponse3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyholder3UsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary createSsoInternalAccountUsingPOST
         * @param {SsoAddInternalAccountRequest} internalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSsoInternalAccountUsingPOST(internalAccountRequest: SsoAddInternalAccountRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsoAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSsoInternalAccountUsingPOST(internalAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteAccountUsingDELETE
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccountUsingDELETE(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccountUsingDELETE(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deleteExternalServiceIntegrationUsingDELETE
         * @param {string} integrationName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExternalServiceIntegrationUsingDELETE(integrationName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalServiceIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExternalServiceIntegrationUsingDELETE(integrationName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The operation accepts zip archive, which contains Java Script files. Multipart form with file parameter is expected.
         * @summary deployScriptsUsingPOST
         * @param {any} file 
         * @param {string} [tenantLocator] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployScriptsUsingPOST(file: any, tenantLocator?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployScriptsUsingPOST(file, tenantLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a test configuration
         * @summary DeployTestConfigurationUsingPOST
         * @param {any} zipFile 
         * @param {string} [tenantNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployTestConfigurationUsingPOST(zipFile: any, tenantNameSuffix?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployTestConfigurationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployTestConfigurationUsingPOST(zipFile, tenantNameSuffix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary discardClaimUsingPOST
         * @param {string} claimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discardClaimUsingPOST(claimLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discardClaimUsingPOST(claimLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary findAccountsByHostnameUsingPOST
         * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountsByHostnameUsingPOST(ssoFindByHostnameRequest: SsoFindByHostnameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPagedResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAccountsByHostnameUsingPOST(ssoFindByHostnameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary findAccountsByTenantUsingPOST
         * @param {SsoFindByTenantRequest} ssoFindByTenantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAccountsByTenantUsingPOST(ssoFindByTenantRequest: SsoFindByTenantRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPagedResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAccountsByTenantUsingPOST(ssoFindByTenantRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAccountUsingGET
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountUsingGET(accountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountUsingGET(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getAccountsByTenantUsingGET
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsByTenantUsingGET(cursor?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPagedResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsByTenantUsingGET(cursor, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deliver events with user attribution
         * @summary getAttributedEventsUsingGET
         * @param {number} [endTimestamp] 
         * @param {string} [eventType] 
         * @param {number} [pageSize] 
         * @param {string} [pagingToken] 
         * @param {number} [startTimestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributedEventsUsingGET(endTimestamp?: number, eventType?: string, pageSize?: number, pagingToken?: string, startTimestamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttributedEventsUsingGET(endTimestamp, eventType, pageSize, pagingToken, startTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getClaim3UsingGET
         * @param {string} claimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaim3UsingGET(claimLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaim3UsingGET(claimLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getExternalServiceIntegrationsUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalServiceIntegrationsUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalServiceIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalServiceIntegrationsUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getExternalServiceIntegrationsUsingPOST
         * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalServiceIntegrationsUsingPOST(ssoFindByHostnameRequest: SsoFindByHostnameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalServiceIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalServiceIntegrationsUsingPOST(ssoFindByHostnameRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getFeaturesSummaryUsingGET
         * @param {string} [locators] 
         * @param {string} [memoNamespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeaturesSummaryUsingGET(locators?: string, memoNamespace?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeaturesSummaryUsingGET(locators, memoNamespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getHealthUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPayablesOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayablesOfSubClaimUsingGET(subClaimLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubClaimPayableListsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayablesOfSubClaimUsingGET(subClaimLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getPolicyholder3UsingGET
         * @param {string} policyholderLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyholder3UsingGET(policyholderLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyholderResponse3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyholder3UsingGET(policyholderLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getReserveHistoryUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReserveHistoryUsingGET(subClaimLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReserveHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReserveHistoryUsingGET(subClaimLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getReservesOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReservesOfSubClaimUsingGET(subClaimLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReserveHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReservesOfSubClaimUsingGET(subClaimLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary getSummaryOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSummaryOfSubClaimUsingGET(subClaimLocator: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubClaimSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSummaryOfSubClaimUsingGET(subClaimLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary hostnameForAdminUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hostnameForAdminUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SsoFindTenantsForAdminResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hostnameForAdminUsingGET(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary querySsoLogsUsingPOST
         * @param {SsoQueryLogRequest} queryLogs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async querySsoLogsUsingPOST(queryLogs: SsoQueryLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.querySsoLogsUsingPOST(queryLogs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The POST body contains JSON with parameters for retrieving scripting logs.
         * @summary queryUsingPOST
         * @param {QueryRequest} query 
         * @param {string} [tenantLocator] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUsingPOST(query: QueryRequest, tenantLocator?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryUsingPOST(query, tenantLocator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary renewAuthentication3UsingPOST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renewAuthentication3UsingPOST(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateResponse3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renewAuthentication3UsingPOST(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary setPasswordUsingPATCH
         * @param {PasswordChangeRequest} passwordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPasswordUsingPATCH(passwordRequest: PasswordChangeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPasswordUsingPATCH(passwordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary setPasswordUsingPUT
         * @param {string} accountId 
         * @param {AccountPasswordRequest} passwordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPasswordUsingPUT(accountId: string, passwordRequest: AccountPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPasswordUsingPUT(accountId, passwordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary setStatusUsingPUT
         * @param {string} accountId 
         * @param {AccountStatusRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStatusUsingPUT(accountId: string, request: AccountStatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStatusUsingPUT(accountId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unlockAccountUsingPOST
         * @param {AccountUnlockRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockAccountUsingPOST(request: AccountUnlockRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockAccountUsingPOST(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateAccountUsingPATCH
         * @param {string} accountId 
         * @param {AccountUpdateRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccountUsingPATCH(accountId: string, accountRequest: AccountUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccountUsingPATCH(accountId, accountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateClaim3UsingPOST
         * @param {string} claimLocator 
         * @param {Claim3UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClaim3UsingPOST(claimLocator: string, updateRequest: Claim3UpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Claim3Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClaim3UsingPOST(claimLocator, updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updateExternalServiceIntegrationUsingPUT
         * @param {string} integrationName 
         * @param {ExternalServiceIntegrationUpdateRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExternalServiceIntegrationUsingPUT(integrationName: string, request: ExternalServiceIntegrationUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalServiceIntegrationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExternalServiceIntegrationUsingPUT(integrationName, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary updatePolicyholder3UsingPOST
         * @param {PolicyholderUpdateRequest2} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyholder3UsingPOST(updateRequest: PolicyholderUpdateRequest2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyholderResponse3>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyholder3UsingPOST(updateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary addAccountUsingPOST
         * @param {AccountAddRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountUsingPOST(accountRequest: AccountAddRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.addAccountUsingPOST(accountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary addExternalServiceIntegrationUsingPOST
         * @param {ExternalServiceIntegrationAddRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExternalServiceIntegrationUsingPOST(request: ExternalServiceIntegrationAddRequest, options?: any): AxiosPromise<ExternalServiceIntegrationsResponse> {
            return localVarFp.addExternalServiceIntegrationUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary authenticate3UsingPOST
         * @param {string} [hostName] 
         * @param {string} [tenantName] 
         * @param {AuthenticateRequest3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate3UsingPOST(hostName?: string, tenantName?: string, body?: AuthenticateRequest3, options?: any): AxiosPromise<AuthenticateResponse3> {
            return localVarFp.authenticate3UsingPOST(hostName, tenantName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary authenticateAdminUsingPOST
         * @param {string} [hostName] 
         * @param {string} [tenantLocator] 
         * @param {string} [tenantName] 
         * @param {AuthenticateRequest3} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateAdminUsingPOST(hostName?: string, tenantLocator?: string, tenantName?: string, body?: AuthenticateRequest3, options?: any): AxiosPromise<AuthenticateResponse3> {
            return localVarFp.authenticateAdminUsingPOST(hostName, tenantLocator, tenantName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary batchUpdateExternalServiceIntegrationsUsingPUT
         * @param {ExternalServiceIntegrationBatchUpdateRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUpdateExternalServiceIntegrationsUsingPUT(request: ExternalServiceIntegrationBatchUpdateRequest, options?: any): AxiosPromise<ExternalServiceIntegrationsResponse> {
            return localVarFp.batchUpdateExternalServiceIntegrationsUsingPUT(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createClaim3UsingPOST
         * @param {Claim3CreateRequest} createRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClaim3UsingPOST(createRequest: Claim3CreateRequest, options?: any): AxiosPromise<Claim3Response> {
            return localVarFp.createClaim3UsingPOST(createRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createPolicyholder3UsingPOST
         * @param {PolicyholderCreateRequest2} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyholder3UsingPOST(request: PolicyholderCreateRequest2, options?: any): AxiosPromise<PolicyholderResponse3> {
            return localVarFp.createPolicyholder3UsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary createSsoInternalAccountUsingPOST
         * @param {SsoAddInternalAccountRequest} internalAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSsoInternalAccountUsingPOST(internalAccountRequest: SsoAddInternalAccountRequest, options?: any): AxiosPromise<SsoAccountResponse> {
            return localVarFp.createSsoInternalAccountUsingPOST(internalAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteAccountUsingDELETE
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountUsingDELETE(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccountUsingDELETE(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deleteExternalServiceIntegrationUsingDELETE
         * @param {string} integrationName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExternalServiceIntegrationUsingDELETE(integrationName: string, options?: any): AxiosPromise<ExternalServiceIntegrationsResponse> {
            return localVarFp.deleteExternalServiceIntegrationUsingDELETE(integrationName, options).then((request) => request(axios, basePath));
        },
        /**
         * The operation accepts zip archive, which contains Java Script files. Multipart form with file parameter is expected.
         * @summary deployScriptsUsingPOST
         * @param {any} file 
         * @param {string} [tenantLocator] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployScriptsUsingPOST(file: any, tenantLocator?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deployScriptsUsingPOST(file, tenantLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a test configuration
         * @summary DeployTestConfigurationUsingPOST
         * @param {any} zipFile 
         * @param {string} [tenantNameSuffix] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployTestConfigurationUsingPOST(zipFile: any, tenantNameSuffix?: string, options?: any): AxiosPromise<DeployTestConfigurationResponse> {
            return localVarFp.deployTestConfigurationUsingPOST(zipFile, tenantNameSuffix, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary discardClaimUsingPOST
         * @param {string} claimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discardClaimUsingPOST(claimLocator: string, options?: any): AxiosPromise<void> {
            return localVarFp.discardClaimUsingPOST(claimLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findAccountsByHostnameUsingPOST
         * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByHostnameUsingPOST(ssoFindByHostnameRequest: SsoFindByHostnameRequest, options?: any): AxiosPromise<AccountPagedResultResponse> {
            return localVarFp.findAccountsByHostnameUsingPOST(ssoFindByHostnameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findAccountsByTenantUsingPOST
         * @param {SsoFindByTenantRequest} ssoFindByTenantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAccountsByTenantUsingPOST(ssoFindByTenantRequest: SsoFindByTenantRequest, options?: any): AxiosPromise<AccountPagedResultResponse> {
            return localVarFp.findAccountsByTenantUsingPOST(ssoFindByTenantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAccountUsingGET
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountUsingGET(accountId: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.getAccountUsingGET(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAccountsByTenantUsingGET
         * @param {string} [cursor] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsByTenantUsingGET(cursor?: string, limit?: number, options?: any): AxiosPromise<AccountPagedResultResponse> {
            return localVarFp.getAccountsByTenantUsingGET(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Deliver events with user attribution
         * @summary getAttributedEventsUsingGET
         * @param {number} [endTimestamp] 
         * @param {string} [eventType] 
         * @param {number} [pageSize] 
         * @param {string} [pagingToken] 
         * @param {number} [startTimestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributedEventsUsingGET(endTimestamp?: number, eventType?: string, pageSize?: number, pagingToken?: string, startTimestamp?: number, options?: any): AxiosPromise<EventPageResponse> {
            return localVarFp.getAttributedEventsUsingGET(endTimestamp, eventType, pageSize, pagingToken, startTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getClaim3UsingGET
         * @param {string} claimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaim3UsingGET(claimLocator: string, options?: any): AxiosPromise<Claim3Response> {
            return localVarFp.getClaim3UsingGET(claimLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getExternalServiceIntegrationsUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalServiceIntegrationsUsingGET(options?: any): AxiosPromise<ExternalServiceIntegrationsResponse> {
            return localVarFp.getExternalServiceIntegrationsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getExternalServiceIntegrationsUsingPOST
         * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalServiceIntegrationsUsingPOST(ssoFindByHostnameRequest: SsoFindByHostnameRequest, options?: any): AxiosPromise<ExternalServiceIntegrationsResponse> {
            return localVarFp.getExternalServiceIntegrationsUsingPOST(ssoFindByHostnameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getFeaturesSummaryUsingGET
         * @param {string} [locators] 
         * @param {string} [memoNamespace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesSummaryUsingGET(locators?: string, memoNamespace?: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getFeaturesSummaryUsingGET(locators, memoNamespace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getHealthUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthUsingGET(options?: any): AxiosPromise<HealthResponse> {
            return localVarFp.getHealthUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPayablesOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayablesOfSubClaimUsingGET(subClaimLocator: string, options?: any): AxiosPromise<SubClaimPayableListsResponse> {
            return localVarFp.getPayablesOfSubClaimUsingGET(subClaimLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPolicyholder3UsingGET
         * @param {string} policyholderLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyholder3UsingGET(policyholderLocator: string, options?: any): AxiosPromise<PolicyholderResponse3> {
            return localVarFp.getPolicyholder3UsingGET(policyholderLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getReserveHistoryUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReserveHistoryUsingGET(subClaimLocator: string, options?: any): AxiosPromise<ReserveHistoryResponse> {
            return localVarFp.getReserveHistoryUsingGET(subClaimLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getReservesOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReservesOfSubClaimUsingGET(subClaimLocator: string, options?: any): AxiosPromise<ReserveHistoryResponse> {
            return localVarFp.getReservesOfSubClaimUsingGET(subClaimLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getSummaryOfSubClaimUsingGET
         * @param {string} subClaimLocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryOfSubClaimUsingGET(subClaimLocator: string, options?: any): AxiosPromise<SubClaimSummary> {
            return localVarFp.getSummaryOfSubClaimUsingGET(subClaimLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary hostnameForAdminUsingGET
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hostnameForAdminUsingGET(options?: any): AxiosPromise<Array<SsoFindTenantsForAdminResponse>> {
            return localVarFp.hostnameForAdminUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary querySsoLogsUsingPOST
         * @param {SsoQueryLogRequest} queryLogs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySsoLogsUsingPOST(queryLogs: SsoQueryLogRequest, options?: any): AxiosPromise<QueryResponse> {
            return localVarFp.querySsoLogsUsingPOST(queryLogs, options).then((request) => request(axios, basePath));
        },
        /**
         * The POST body contains JSON with parameters for retrieving scripting logs.
         * @summary queryUsingPOST
         * @param {QueryRequest} query 
         * @param {string} [tenantLocator] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUsingPOST(query: QueryRequest, tenantLocator?: string, options?: any): AxiosPromise<QueryResponse> {
            return localVarFp.queryUsingPOST(query, tenantLocator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary renewAuthentication3UsingPOST
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewAuthentication3UsingPOST(options?: any): AxiosPromise<AuthenticateResponse3> {
            return localVarFp.renewAuthentication3UsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setPasswordUsingPATCH
         * @param {PasswordChangeRequest} passwordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordUsingPATCH(passwordRequest: PasswordChangeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setPasswordUsingPATCH(passwordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setPasswordUsingPUT
         * @param {string} accountId 
         * @param {AccountPasswordRequest} passwordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPasswordUsingPUT(accountId: string, passwordRequest: AccountPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setPasswordUsingPUT(accountId, passwordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary setStatusUsingPUT
         * @param {string} accountId 
         * @param {AccountStatusRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStatusUsingPUT(accountId: string, request: AccountStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.setStatusUsingPUT(accountId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unlockAccountUsingPOST
         * @param {AccountUnlockRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockAccountUsingPOST(request: AccountUnlockRequest, options?: any): AxiosPromise<void> {
            return localVarFp.unlockAccountUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateAccountUsingPATCH
         * @param {string} accountId 
         * @param {AccountUpdateRequest} accountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountUsingPATCH(accountId: string, accountRequest: AccountUpdateRequest, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.updateAccountUsingPATCH(accountId, accountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateClaim3UsingPOST
         * @param {string} claimLocator 
         * @param {Claim3UpdateRequest} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClaim3UsingPOST(claimLocator: string, updateRequest: Claim3UpdateRequest, options?: any): AxiosPromise<Claim3Response> {
            return localVarFp.updateClaim3UsingPOST(claimLocator, updateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateExternalServiceIntegrationUsingPUT
         * @param {string} integrationName 
         * @param {ExternalServiceIntegrationUpdateRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExternalServiceIntegrationUsingPUT(integrationName: string, request: ExternalServiceIntegrationUpdateRequest, options?: any): AxiosPromise<ExternalServiceIntegrationsResponse> {
            return localVarFp.updateExternalServiceIntegrationUsingPUT(integrationName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updatePolicyholder3UsingPOST
         * @param {PolicyholderUpdateRequest2} updateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyholder3UsingPOST(updateRequest: PolicyholderUpdateRequest2, options?: any): AxiosPromise<PolicyholderResponse3> {
            return localVarFp.updatePolicyholder3UsingPOST(updateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary addAccountUsingPOST
     * @param {AccountAddRequest} accountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addAccountUsingPOST(accountRequest: AccountAddRequest, options?: any) {
        return DefaultApiFp(this.configuration).addAccountUsingPOST(accountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary addExternalServiceIntegrationUsingPOST
     * @param {ExternalServiceIntegrationAddRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addExternalServiceIntegrationUsingPOST(request: ExternalServiceIntegrationAddRequest, options?: any) {
        return DefaultApiFp(this.configuration).addExternalServiceIntegrationUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary authenticate3UsingPOST
     * @param {string} [hostName] 
     * @param {string} [tenantName] 
     * @param {AuthenticateRequest3} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authenticate3UsingPOST(hostName?: string, tenantName?: string, body?: AuthenticateRequest3, options?: any) {
        return DefaultApiFp(this.configuration).authenticate3UsingPOST(hostName, tenantName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary authenticateAdminUsingPOST
     * @param {string} [hostName] 
     * @param {string} [tenantLocator] 
     * @param {string} [tenantName] 
     * @param {AuthenticateRequest3} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public authenticateAdminUsingPOST(hostName?: string, tenantLocator?: string, tenantName?: string, body?: AuthenticateRequest3, options?: any) {
        return DefaultApiFp(this.configuration).authenticateAdminUsingPOST(hostName, tenantLocator, tenantName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary batchUpdateExternalServiceIntegrationsUsingPUT
     * @param {ExternalServiceIntegrationBatchUpdateRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchUpdateExternalServiceIntegrationsUsingPUT(request: ExternalServiceIntegrationBatchUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).batchUpdateExternalServiceIntegrationsUsingPUT(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createClaim3UsingPOST
     * @param {Claim3CreateRequest} createRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createClaim3UsingPOST(createRequest: Claim3CreateRequest, options?: any) {
        return DefaultApiFp(this.configuration).createClaim3UsingPOST(createRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createPolicyholder3UsingPOST
     * @param {PolicyholderCreateRequest2} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createPolicyholder3UsingPOST(request: PolicyholderCreateRequest2, options?: any) {
        return DefaultApiFp(this.configuration).createPolicyholder3UsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary createSsoInternalAccountUsingPOST
     * @param {SsoAddInternalAccountRequest} internalAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createSsoInternalAccountUsingPOST(internalAccountRequest: SsoAddInternalAccountRequest, options?: any) {
        return DefaultApiFp(this.configuration).createSsoInternalAccountUsingPOST(internalAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteAccountUsingDELETE
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteAccountUsingDELETE(accountId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteAccountUsingDELETE(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deleteExternalServiceIntegrationUsingDELETE
     * @param {string} integrationName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteExternalServiceIntegrationUsingDELETE(integrationName: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteExternalServiceIntegrationUsingDELETE(integrationName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The operation accepts zip archive, which contains Java Script files. Multipart form with file parameter is expected.
     * @summary deployScriptsUsingPOST
     * @param {any} file 
     * @param {string} [tenantLocator] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployScriptsUsingPOST(file: any, tenantLocator?: string, options?: any) {
        return DefaultApiFp(this.configuration).deployScriptsUsingPOST(file, tenantLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a test configuration
     * @summary DeployTestConfigurationUsingPOST
     * @param {any} zipFile 
     * @param {string} [tenantNameSuffix] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deployTestConfigurationUsingPOST(zipFile: any, tenantNameSuffix?: string, options?: any) {
        return DefaultApiFp(this.configuration).deployTestConfigurationUsingPOST(zipFile, tenantNameSuffix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary discardClaimUsingPOST
     * @param {string} claimLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public discardClaimUsingPOST(claimLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).discardClaimUsingPOST(claimLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findAccountsByHostnameUsingPOST
     * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAccountsByHostnameUsingPOST(ssoFindByHostnameRequest: SsoFindByHostnameRequest, options?: any) {
        return DefaultApiFp(this.configuration).findAccountsByHostnameUsingPOST(ssoFindByHostnameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findAccountsByTenantUsingPOST
     * @param {SsoFindByTenantRequest} ssoFindByTenantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAccountsByTenantUsingPOST(ssoFindByTenantRequest: SsoFindByTenantRequest, options?: any) {
        return DefaultApiFp(this.configuration).findAccountsByTenantUsingPOST(ssoFindByTenantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAccountUsingGET
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccountUsingGET(accountId: string, options?: any) {
        return DefaultApiFp(this.configuration).getAccountUsingGET(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAccountsByTenantUsingGET
     * @param {string} [cursor] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccountsByTenantUsingGET(cursor?: string, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).getAccountsByTenantUsingGET(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deliver events with user attribution
     * @summary getAttributedEventsUsingGET
     * @param {number} [endTimestamp] 
     * @param {string} [eventType] 
     * @param {number} [pageSize] 
     * @param {string} [pagingToken] 
     * @param {number} [startTimestamp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAttributedEventsUsingGET(endTimestamp?: number, eventType?: string, pageSize?: number, pagingToken?: string, startTimestamp?: number, options?: any) {
        return DefaultApiFp(this.configuration).getAttributedEventsUsingGET(endTimestamp, eventType, pageSize, pagingToken, startTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getClaim3UsingGET
     * @param {string} claimLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getClaim3UsingGET(claimLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).getClaim3UsingGET(claimLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getExternalServiceIntegrationsUsingGET
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExternalServiceIntegrationsUsingGET(options?: any) {
        return DefaultApiFp(this.configuration).getExternalServiceIntegrationsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getExternalServiceIntegrationsUsingPOST
     * @param {SsoFindByHostnameRequest} ssoFindByHostnameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExternalServiceIntegrationsUsingPOST(ssoFindByHostnameRequest: SsoFindByHostnameRequest, options?: any) {
        return DefaultApiFp(this.configuration).getExternalServiceIntegrationsUsingPOST(ssoFindByHostnameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getFeaturesSummaryUsingGET
     * @param {string} [locators] 
     * @param {string} [memoNamespace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFeaturesSummaryUsingGET(locators?: string, memoNamespace?: string, options?: any) {
        return DefaultApiFp(this.configuration).getFeaturesSummaryUsingGET(locators, memoNamespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getHealthUsingGET
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealthUsingGET(options?: any) {
        return DefaultApiFp(this.configuration).getHealthUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPayablesOfSubClaimUsingGET
     * @param {string} subClaimLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPayablesOfSubClaimUsingGET(subClaimLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).getPayablesOfSubClaimUsingGET(subClaimLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPolicyholder3UsingGET
     * @param {string} policyholderLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPolicyholder3UsingGET(policyholderLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).getPolicyholder3UsingGET(policyholderLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getReserveHistoryUsingGET
     * @param {string} subClaimLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReserveHistoryUsingGET(subClaimLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).getReserveHistoryUsingGET(subClaimLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getReservesOfSubClaimUsingGET
     * @param {string} subClaimLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getReservesOfSubClaimUsingGET(subClaimLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).getReservesOfSubClaimUsingGET(subClaimLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getSummaryOfSubClaimUsingGET
     * @param {string} subClaimLocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSummaryOfSubClaimUsingGET(subClaimLocator: string, options?: any) {
        return DefaultApiFp(this.configuration).getSummaryOfSubClaimUsingGET(subClaimLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary hostnameForAdminUsingGET
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public hostnameForAdminUsingGET(options?: any) {
        return DefaultApiFp(this.configuration).hostnameForAdminUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary querySsoLogsUsingPOST
     * @param {SsoQueryLogRequest} queryLogs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public querySsoLogsUsingPOST(queryLogs: SsoQueryLogRequest, options?: any) {
        return DefaultApiFp(this.configuration).querySsoLogsUsingPOST(queryLogs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The POST body contains JSON with parameters for retrieving scripting logs.
     * @summary queryUsingPOST
     * @param {QueryRequest} query 
     * @param {string} [tenantLocator] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public queryUsingPOST(query: QueryRequest, tenantLocator?: string, options?: any) {
        return DefaultApiFp(this.configuration).queryUsingPOST(query, tenantLocator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary renewAuthentication3UsingPOST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public renewAuthentication3UsingPOST(options?: any) {
        return DefaultApiFp(this.configuration).renewAuthentication3UsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setPasswordUsingPATCH
     * @param {PasswordChangeRequest} passwordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setPasswordUsingPATCH(passwordRequest: PasswordChangeRequest, options?: any) {
        return DefaultApiFp(this.configuration).setPasswordUsingPATCH(passwordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setPasswordUsingPUT
     * @param {string} accountId 
     * @param {AccountPasswordRequest} passwordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setPasswordUsingPUT(accountId: string, passwordRequest: AccountPasswordRequest, options?: any) {
        return DefaultApiFp(this.configuration).setPasswordUsingPUT(accountId, passwordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary setStatusUsingPUT
     * @param {string} accountId 
     * @param {AccountStatusRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setStatusUsingPUT(accountId: string, request: AccountStatusRequest, options?: any) {
        return DefaultApiFp(this.configuration).setStatusUsingPUT(accountId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unlockAccountUsingPOST
     * @param {AccountUnlockRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unlockAccountUsingPOST(request: AccountUnlockRequest, options?: any) {
        return DefaultApiFp(this.configuration).unlockAccountUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateAccountUsingPATCH
     * @param {string} accountId 
     * @param {AccountUpdateRequest} accountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateAccountUsingPATCH(accountId: string, accountRequest: AccountUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).updateAccountUsingPATCH(accountId, accountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateClaim3UsingPOST
     * @param {string} claimLocator 
     * @param {Claim3UpdateRequest} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateClaim3UsingPOST(claimLocator: string, updateRequest: Claim3UpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).updateClaim3UsingPOST(claimLocator, updateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateExternalServiceIntegrationUsingPUT
     * @param {string} integrationName 
     * @param {ExternalServiceIntegrationUpdateRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateExternalServiceIntegrationUsingPUT(integrationName: string, request: ExternalServiceIntegrationUpdateRequest, options?: any) {
        return DefaultApiFp(this.configuration).updateExternalServiceIntegrationUsingPUT(integrationName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updatePolicyholder3UsingPOST
     * @param {PolicyholderUpdateRequest2} updateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updatePolicyholder3UsingPOST(updateRequest: PolicyholderUpdateRequest2, options?: any) {
        return DefaultApiFp(this.configuration).updatePolicyholder3UsingPOST(updateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
